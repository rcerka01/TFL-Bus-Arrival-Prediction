package controllers

import be.objectify.deadbolt.scala.DeadboltActions
import com.google.inject.Inject
import models.autogenerated.Tables.JobsRow
import services.JobServices
import play.api.Play
import play.api.Play.current
import play.api.data.Form
import play.api.data.Forms._
import play.api.i18n.{I18nSupport, MessagesApi}
import play.api.libs.json._
import play.api.libs.ws.WS
import play.api.mvc._

import scala.concurrent.ExecutionContext.Implicits.global

case class JobForm( busnr: String, busstop:String, direction: String)

class JobsController @Inject() (deadbolt: DeadboltActions, val messagesApi: MessagesApi) extends Controller  with I18nSupport {


  /**
   * Globals
   */
  val id = Play.current.configuration.getString("tfl.id").get
  val key = Play.current.configuration.getString("tfl.key").get


  /**
   * Forms
   */
  val jobForm = Form(
    mapping(
      "busnr" -> nonEmptyText,
      "busstop" -> nonEmptyText,
      "direction" -> nonEmptyText
    )(JobForm.apply)(JobForm.unapply)
  )


  /**
   * Initial action
   */
  def selectedRoutes =  {
    Action { implicit request =>
      val stopsSeq: Seq[(String, String)] = Seq("Choose Stop Point" -> "")
      Ok(views.html.jobs.selectedRoutes(stopsSeq, jobForm))
    }
  }


  /**
   * Gett Busstops
   */
  def getStops(nr: String) = {
    Action.async { implicit request =>

      WS
        .url("https://api.tfl.gov.uk/Line/" + nr + "/StopPoints?app_id=" + id + "&app_key=" + key)
        .get()
        .map(response => {
        val inJsArray: JsArray = Json.parse(response.body).as[JsArray]
        var outJsArray: JsArray = Json.arr()
        var propJsArray: JsArray = Json.arr()

        // Obviously here must be done any error checking

        // Foreach Json object
        inJsArray.value foreach { jsBusstopObject =>

          // Sub Json array
          propJsArray = (jsBusstopObject \ "additionalProperties").get.as[JsArray]
          var towards = ""

          // Foreach sub Json, to populate "towards" string if value exist
          propJsArray.value foreach { prop =>

            (prop \ "key").as[String] match {
              case "Towards" => if (!(prop \ "value").as[String].isEmpty)
                towards = "  -  Towards  ->  " + (prop \ "value").as[String]
              case _ => ""
            }
          }

          // Use for return only if "indicator" property exist
          val testProp = (jsBusstopObject \ "indicator").validate[String]
          // Validate against "indicator" existence
          testProp match {
            case JsSuccess(_, _) => {
              outJsArray :+=
                Json.obj(
                  "id" -> Json.toJson((jsBusstopObject \ "id").get.as[String]),
                  "name" -> Json.toJson((jsBusstopObject \ "commonName").get.as[String] + towards),
                  "lat" -> Json.toJson((jsBusstopObject \ "lat").get.as[Float]),
                  "lon" -> Json.toJson((jsBusstopObject \ "lon").get.as[Float])
                )
            }
            case JsError(_) => None
          }
        }
        Ok(outJsArray).withHeaders("Access-Control-Allow-Origin"->"*")
      })
    }
  }



    /**
     * Get Predictions
     */
    def predict(nr: String, st: String) =  {
      Action.async { implicit request =>

        WS
          .url("https://api.tfl.gov.uk/Line/" + nr + "/Arrivals/" + st + "?app_id=" + id + "&app_key=" + key)
          .get()
          .map(response => {

          val inJsArray: JsArray = Json.parse(response.body).as[JsArray]
          var outJsArray: JsArray = Json.arr()

          inJsArray.value foreach (jsObject => {
            outJsArray :+=
              Json.obj(
                "timeToStation" -> Json.toJson((jsObject \ "timeToStation").get.as[Int])
              )
          })

          Ok(outJsArray).withHeaders("Access-Control-Allow-Origin"->"*")
        })
      }
    }




  /**
   * Save current route
   */
  def saveRoute(nr: String, stId: String, stName: String) = deadbolt.Restrict(List(Array("user"))) {
    Action { implicit request =>

      // error handling must be here, however it will never be executed without a secure session
      val id = request.session.get("secure.id").get
      val job = new JobsRow(0, Option(nr), Option(stId), id.toInt,  Option(stName))
      JobServices.saveJob(job)
      Ok
    }
  }




  /**
   * Save current route
   */
  def getSavedJobs() = deadbolt.Restrict(List(Array("user"))) {
    Action.async { implicit request =>

      JobServices.findJobsByUserId(request.session.get("secure.id").get.toInt) map{ jobs =>

        var json: JsArray = Json.arr()

        jobs foreach {job =>
          json :+=
            Json.obj(
              "id"          -> JsNumber(job.id),
              "busnumber"   -> JsString(job.busnr.get),
              "busstopid"   -> JsString(job.busstopId.get),
              "busstopname" -> JsString(job.busstopName.get)
            )
        }

        Ok(Json.toJson(json))
      }
    }
  }



  /**
   *  Delete saved route
   */
  def deleteJob(id: String) = deadbolt.Restrict(List(Array("user"))) {
    Action { implicit request =>
      JobServices.deleteJob(id.toInt);
      Ok
    }
  }




}


